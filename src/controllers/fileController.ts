import { Request, Response } from "express";
import { v4 as uuidv4 } from "uuid";
import fs from "fs";
import path from "path";
import {
  completeUpload,
  failUpload,
  getUploadProgress,
  initUploadProgress,
  updateUploadProgress,
} from "../services/uploadProgressService";
import { FileDocument } from "../types/ragTypes";
import {
  emitProcessingStart,
  emitProcessingProgress,
  emitProcessingComplete,
  emitProcessingError,
} from "../services/socketService";
import {
  prepareFileForProcessing,
  processFileAndAddToVectorStore,
} from "../services/fileService";

// Store in-memory maps of pending files and their upload IDs
// In a production environment, this would be stored in a database
const pendingFiles = new Map<string, FileDocument[]>();
const processingStatus = new Map<
  string,
  "pending" | "processing" | "completed" | "error"
>();
const fileIdToUploadId = new Map<string, string>();

/**
 * Handle file upload
 */
export async function uploadFile(req: Request, res: Response) {
  try {
    // Get uploadId generated by the uploadMiddleware
    const uploadId = req.uploadId || "";
    if (!uploadId) {
      return res.status(400).json({
        error: "Bad Request",
        message: "No upload ID provided",
      });
    }

    // Check if a file was provided (this should be handled by the middleware)
    if (!req.file) {
      failUpload(uploadId, "No file was uploaded");
      return res.status(400).json({
        error: "Bad Request",
        message: "No file was uploaded",
      });
    }

    // Retrieve the uploaded file details
    const { path: filePath, originalname, mimetype, size } = req.file;

    // Generate a unique fileId for this upload
    const fileId = path.basename(filePath);

    try {
      // Create a file document entry
      const fileDoc: FileDocument = {
        id: fileId,
        filePath,
        fileType: mimetype,
        originalName: originalname,
        status: "uploaded",
        metadata: {
          fileSize: size,
          uploadDate: new Date().toISOString(),
        },
      };

      // Associate this file with the upload ID
      if (!pendingFiles.has(uploadId)) {
        pendingFiles.set(uploadId, []);
      }
      pendingFiles.get(uploadId)?.push(fileDoc);
      fileIdToUploadId.set(fileId, uploadId);

      // Mark the upload as complete with the file details
      completeUpload(uploadId, {
        message: "File uploaded successfully and ready for processing",
        filename: originalname,
        fileId,
        status: "uploaded",
      });

      // Return success response
      return res.status(200).json({
        message: "File uploaded successfully and ready for processing",
        filename: originalname,
        fileId,
        uploadId,
        status: "uploaded",
        files: pendingFiles.get(uploadId),
      });
    } catch (error) {
      console.error("Error processing upload:", error);
      failUpload(uploadId, "Error processing upload");
      return res.status(500).json({
        error: "Server Error",
        message: "Error processing upload",
      });
    }
  } catch (error) {
    console.error("Unexpected error in uploadFile:", error);
    return res.status(500).json({
      error: "Server Error",
      message: "Unexpected error occurred",
    });
  }
}

/**
 * Process previously uploaded files
 */
export async function processFiles(req: Request, res: Response) {
  try {
    const { uploadId, fileIds } = req.body as {
      uploadId: string;
      fileIds: string[];
    };

    if (!uploadId) {
      return res.status(400).json({
        error: "Bad Request",
        message: "No uploadId provided",
      });
    }

    if (!fileIds || !Array.isArray(fileIds) || fileIds.length === 0) {
      return res.status(400).json({
        error: "Bad Request",
        message: "No fileIds provided or invalid format",
      });
    }

    // Find files to process
    const filesToProcess: FileDocument[] = [];
    for (const fileId of fileIds) {
      // Get the upload ID associated with this file
      const fileUploadId = fileIdToUploadId.get(fileId);
      if (!fileUploadId) {
        console.warn(`File ID ${fileId} not found in any upload`);
        continue;
      }

      // Get pending files for this upload
      const files = pendingFiles.get(fileUploadId);
      if (!files) {
        console.warn(`No pending files found for upload ${fileUploadId}`);
        continue;
      }

      // Find the specific file
      const file = files.find((f) => f.id === fileId);
      if (!file) {
        console.warn(`File ${fileId} not found in upload ${fileUploadId}`);
        continue;
      }

      filesToProcess.push(file);
    }

    if (filesToProcess.length === 0) {
      return res.status(400).json({
        error: "Bad Request",
        message: "No valid files found to process",
      });
    }

    // Generate a unique processing ID
    const processingId = `proc-${Date.now()}-${uploadId}`;

    // Mark files as processing
    filesToProcess.forEach((file) => {
      file.status = "processing";
    });

    // Start processing in background
    processFilesInBackground(uploadId, processingId, filesToProcess).catch(
      (err) => console.error("Background processing error:", err),
    );

    return res.status(202).json({
      message: "File processing started",
      processingId,
      uploadId,
      totalFiles: filesToProcess.length,
      files: filesToProcess.map((f) => ({
        fileId: f.id,
        filename: f.originalName,
      })),
    });
  } catch (error) {
    console.error("Error processing files:", error);
    return res.status(500).json({
      error: "Server Error",
      message: "Error processing files",
    });
  }
}

/**
 * Get files uploaded by upload ID
 */
export async function getUploadedFiles(req: Request, res: Response) {
  try {
    const { uploadId } = req.params;

    if (!uploadId) {
      return res.status(400).json({
        error: "Bad Request",
        message: "No uploadId provided",
      });
    }

    // Get files for this upload
    const files = pendingFiles.get(uploadId) || [];

    // Format the response
    const formattedFiles = files.map((f) => ({
      fileId: f.id,
      filename: f.originalName,
      status: f.status,
      processed: f.processed || false,
      error: f.error,
      metadata: f.metadata,
    }));

    return res.status(200).json({
      uploadId,
      files: formattedFiles,
      totalFiles: formattedFiles.length,
    });
  } catch (error) {
    console.error("Error retrieving uploaded files:", error);
    return res.status(500).json({
      error: "Server Error",
      message: "Error retrieving uploaded files",
    });
  }
}

/**
 * Process files in the background and emit progress events
 */
async function processFilesInBackground(
  uploadId: string,
  processingId: string,
  files: FileDocument[],
) {
  console.log(
    `Starting background processing task for uploadId: ${uploadId}, processingId: ${processingId}, total files: ${files.length}`,
  );
  try {
    const totalFiles = files.length;
    let processedFiles = 0;
    let totalChunks = 0;
    let processedChunks = 0;
    let totalCharacters = 0;
    const results = [];

    // First pass to determine total chunks (for accurate progress reporting)
    emitProcessingStart(uploadId, {
      processingId,
      totalFiles,
      status: "analyzing",
      message: `Analyzing ${totalFiles} files...`,
    });

    // Process each file sequentially
    for (let fileIndex = 0; fileIndex < files.length; fileIndex++) {
      const file = files[fileIndex];
      console.log(
        `Processing file ${fileIndex + 1}/${totalFiles}: ${file.originalName} (fileId: ${file.id})`,
      );
      try {
        // Emit progress update for file start
        const overallProgress = Math.round((processedFiles / totalFiles) * 100);
        emitProcessingProgress(uploadId, {
          uploadId: uploadId, // Ensure uploadId is in the payload
          processingId,
          currentFile: file.originalName,
          fileId: file.id,
          fileIndex: fileIndex,
          processedFiles,
          totalFiles,
          overallProgress,
          percent: overallProgress, // Add this to match frontend expectation
          status: "processing",
          message: `Starting to process file ${fileIndex + 1}/${totalFiles}: ${file.originalName}`,
        });

        // Process the file
        const result = await processFileAndAddToVectorStore(
          file,
          uploadId,
          fileIndex,
          totalFiles,
          processingId,
        );

        console.log(
          `Finished processing file ${file.originalName}. Result: chunks=${result.chunks}, characters=${result.totalCharacters}.`,
        );

        // Update the file status
        file.status = "processed";
        file.processed = true;
        console.log(
          `Updated status for file ${file.originalName} to 'processed'.`,
        );

        // Compile results
        results.push({
          fileId: file.id,
          filename: file.originalName,
          chunks: result.chunks,
          totalCharacters: result.totalCharacters,
        });

        totalChunks += result.chunks;
        totalCharacters += result.totalCharacters;
        processedFiles++;
        processedChunks += result.chunks;

        // Emit progress update for file completion
        const completionOverallProgress = Math.round(
          (processedFiles / totalFiles) * 100,
        );
        const embeddingProgress =
          totalChunks > 0
            ? Math.round((processedChunks / totalChunks) * 100)
            : 100;

        emitProcessingProgress(uploadId, {
          uploadId: uploadId, // Ensure uploadId is in the payload
          processingId,
          currentFile: null, // Clear current file as processing for this one is done
          fileId: null,
          processedFiles,
          totalFiles,
          processedChunks,
          totalChunks,
          overallProgress: completionOverallProgress,
          embeddingProgress,
          percent: completionOverallProgress, // Add this to match frontend expectation
          status: "file_complete",
          message: `Completed processing file ${fileIndex + 1}/${totalFiles}: ${file.originalName}`,
        });

        console.log(
          `Emitted processing progress for file completion: ${file.originalName}.`,
        );
      } catch (error) {
        console.error(`Error processing file ${file.originalName}:`, error);
        file.status = "error";
        file.error = error instanceof Error ? error.message : "Unknown error";
        console.error(`Set status for file ${file.originalName} to 'error'.`);

        // Emit error for this specific file
        emitProcessingError(uploadId, {
          processingId,
          fileId: file.id,
          filename: file.originalName,
          fileIndex,
          totalFiles,
          processedFiles,
          error: file.error,
          status: "error",
          message: `Error processing file ${fileIndex + 1}/${totalFiles}: ${file.originalName}`,
        });

        console.log(
          `Emitted processing error event for file ${file.originalName}.`,
        );
      }
    }

    // Emit completion event
    emitProcessingComplete(uploadId, {
      uploadId: uploadId, // Ensure uploadId is in the payload
      processingId,
      processedFiles,
      totalFiles,
      processedChunks,
      totalChunks,
      totalCharacters,
      overallProgress: 100,
      percent: 100, // Add this to match frontend expectation
      status: "complete",
      message: `Processing completed. Processed ${processedFiles}/${totalFiles} files with ${totalChunks} chunks and ${totalCharacters} characters.`,
      results,
    });

    console.log(
      `Background processing completed for uploadId ${uploadId}. Processed ${processedFiles}/${totalFiles} files. Total chunks: ${totalChunks}, total characters: ${totalCharacters}.`,
    );
  } catch (error) {
    console.error("Error in background processing:", error);
    emitProcessingError(uploadId, {
      processingId,
      error: error instanceof Error ? error.message : "Unknown error occurred",
      status: "error",
      message: "An unexpected error occurred during processing.",
    });

    console.error(
      `Emitted general processing error for processingId ${processingId}.`,
    );
  }
}
